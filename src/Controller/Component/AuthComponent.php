<?php
namespace Custom\Controller\Component;

use Cake\Controller\Controller;
use Cake\Event\Event;
use Cake\Routing\Router;
use Cake\Utility\Hash;

/**
 * Authentication control component class.
 *
 * Binds access control with user authentication and session management.
 *
 * @property \Cake\Controller\Component\RequestHandlerComponent $RequestHandler
 * @property \Cake\Controller\Component\FlashComponent $Flash
 * @link https://book.cakephp.org/3.0/en/controllers/components/authentication.html
 */
class AuthComponent extends \Cake\Controller\Component\AuthComponent
{
    
    /**
     * Default config
     *
     * - `authenticate` - An array of authentication objects to use for authenticating users.
     *   You can configure multiple adapters and they will be checked sequentially
     *   when users are identified.
     *
     *   ```
     *   $this->Auth->setConfig('authenticate', [
     *      'Form' => [
     *         'userModel' => 'Users.Users'
     *      ]
     *   ]);
     *   ```
     *
     *   Using the class name without 'Authenticate' as the key, you can pass in an
     *   array of config for each authentication object. Additionally you can define
     *   config that should be set to all authentications objects using the 'all' key:
     *
     *   ```
     *   $this->Auth->setConfig('authenticate', [
     *       AuthComponent::ALL => [
     *          'userModel' => 'Users.Users',
     *          'scope' => ['Users.active' => 1]
     *      ],
     *     'Form',
     *     'Basic'
     *   ]);
     *   ```
     *
     * - `authorize` - An array of authorization objects to use for authorizing users.
     *   You can configure multiple adapters and they will be checked sequentially
     *   when authorization checks are done.
     *
     *   ```
     *   $this->Auth->setConfig('authorize', [
     *      'Crud' => [
     *          'actionPath' => 'controllers/'
     *      ]
     *   ]);
     *   ```
     *
     *   Using the class name without 'Authorize' as the key, you can pass in an array
     *   of config for each authorization object. Additionally you can define config
     *   that should be set to all authorization objects using the AuthComponent::ALL key:
     *
     *   ```
     *   $this->Auth->setConfig('authorize', [
     *      AuthComponent::ALL => [
     *          'actionPath' => 'controllers/'
     *      ],
     *      'Crud',
     *      'CustomAuth'
     *   ]);
     *   ```
     *
     * - ~~`ajaxLogin`~~ - The name of an optional view element to render when an Ajax
     *   request is made with an invalid or expired session.
     *   **This option is deprecated since 3.3.6.** Your client side code should
     *   instead check for 403 status code and show appropriate login form.
     *
     * - `flash` - Settings to use when Auth needs to do a flash message with
     *   FlashComponent::set(). Available keys are:
     *
     *   - `key` - The message domain to use for flashes generated by this component,
     *     defaults to 'auth'.
     *   - `element` - Flash element to use, defaults to 'default'.
     *   - `params` - The array of additional params to use, defaults to ['class' => 'error']
     *
     * - `loginAction` - A URL (defined as a string or array) to the controller action
     *   that handles logins. Defaults to `/users/login`.
     *
     * - `loginRedirect` - Normally, if a user is redirected to the `loginAction` page,
     *   the location they were redirected from will be stored in the session so that
     *   they can be redirected back after a successful login. If this session value
     *   is not set, redirectUrl() method will return the URL specified in `loginRedirect`.
     *
     * - `logoutRedirect` - The default action to redirect to after the user is logged out.
     *   While AuthComponent does not handle post-logout redirection, a redirect URL
     *   will be returned from `AuthComponent::logout()`. Defaults to `loginAction`.
     *
     * - `authError` - Error to display when user attempts to access an object or
     *   action to which they do not have access.
     *
     * - `unauthorizedRedirect` - Controls handling of unauthorized access.
     *
     *   - For default value `true` unauthorized user is redirected to the referrer URL
     *     or `$loginRedirect` or '/'.
     *   - If set to a string or array the value is used as a URL to redirect to.
     *   - If set to false a `ForbiddenException` exception is thrown instead of redirecting.
     *
     * - `storage` - Storage class to use for persisting user record. When using
     *   stateless authenticator you should set this to 'Memory'. Defaults to 'Session'.
     *
     * - `checkAuthIn` - Name of event for which initial auth checks should be done.
     *   Defaults to 'Controller.startup'. You can set it to 'Controller.initialize'
     *   if you want the check to be done before controller's beforeFilter() is run.
     *
     * @var array
     */
    protected $_defaultConfig = [
        'authenticate' => null,
        'authorize' => null,
        'ajaxLogin' => null,
        'flash' => null,
        'loginAction' => null,
        'loginRedirect' => null,
        'logoutRedirect' => null,
        'authError' => null,
        'unauthorizedRedirect' => true,
        'storage' => 'Custom.Session', // Hack from extended. Storage from custom
        'checkAuthIn' => 'Controller.startup'
    ];

    /**
     * Main execution method, handles initial authentication check and redirection
     * of invalid users.
     *
     * The auth check is done when event name is same as the one configured in
     * `checkAuthIn` config.
     *
     * @param \Cake\Event\Event $event Event instance.
     * @return \Cake\Http\Response|null
     * @throws \ReflectionException
     */
    public function authCheck(Event $event)
    {
        if ($this->_config['checkAuthIn'] !== $event->getName()) {
            return null;
        }

        /** @var \Cake\Controller\Controller $controller */
        $controller = $event->getSubject();

        $action = strtolower($controller->getRequest()->getParam('action'));
        if (!$controller->isAction($action)) {
            return null;
        }

        $this->_setDefaults();

        if ($this->_isAllowed($controller)) {
            return null;
        }

        $isLoginAction = $this->_isLoginAction($controller);
		// Hack from extended. Start. Bypass a las acciones de logout y de redirección de login para que no ocacionen bucles de redirecciones infinitas.
        $isLogoutAction = $this->_isLogoutAction($controller);
        $isLoginRedirect = $this->_isLoginRedirect($controller);
		// Hack from extended. End. Bypass a las acciones de logout y de redirección de login para que no ocacionen bucles de redirecciones infinitas.

        if (!$this->_getUser()) {
            if ($isLoginAction) {
                return null;
            }
            $result = $this->_unauthenticated($controller);
            if ($result instanceof Response) {
                $event->stopPropagation();
            }

            return $result;
        }

		
		// Hack from extended. Start. Bypass a las acciones de logout y de redirección de login para que no ocacionen bucles de redirecciones infinitas.
        if ($isLoginAction || $isLogoutAction || $isLoginRedirect) {
            return null;
        }
		// Hack from extended. End. Bypass a las acciones de logout y de redirección de login para que no ocacionen bucles de redirecciones infinitas.

        if ($isLoginAction ||
            empty($this->_config['authorize']) ||
            $this->isAuthorized($this->user())
        ) {
            return null;
        }

        $event->stopPropagation();

        return $this->_unauthorized($controller);
    }

    /**
     * Normalizes config `logoutAction` and checks if current request URL is same as logout action.
     *
     * @param \Cake\Controller\Controller $controller A reference to the controller object.
     * @return bool True if current action is logout action else false.
     */
    protected function _isLogoutAction(Controller $controller)
    {
        $uri = $controller->request->getUri();
        $url = Router::normalize($uri->getPath());
        $logoutAction = Router::normalize($this->_config['logoutAction']);

        return $logoutAction === $url;
    }

    /**
     * Normalizes config `loginRedirect` and checks if current request URL is same as logout action.
     *
     * @param \Cake\Controller\Controller $controller A reference to the controller object.
     * @return bool True if current action is logout action else false.
     */
    protected function _isLoginRedirect(Controller $controller)
    {
        $uri = $controller->request->getUri();
        $url = Router::normalize($uri->getPath());
        $loginRedirect = Router::normalize($this->redirectUrl());

        return $loginRedirect === $url;
    }
    
    /**
     * Handles unauthenticated access attempt. First the `unauthenticated()` method
     * of the last authenticator in the chain will be called. The authenticator can
     * handle sending response or redirection as appropriate and return `true` to
     * indicate no further action is necessary. If authenticator returns null this
     * method redirects user to login action. If it's an AJAX request and config
     * `ajaxLogin` is specified that element is rendered else a 403 HTTP status code
     * is returned.
     *
     * @param \Cake\Controller\Controller $controller A reference to the controller object.
     * @return \Cake\Http\Response|null Null if current action is login action
     *   else response object returned by authenticate object or Controller::redirect().
     * @throws \Cake\Core\Exception\Exception
     */
    protected function _unauthenticated(Controller $controller)
    {
        if (empty($this->_authenticateObjects)) {
            $this->constructAuthenticate();
        }
        $response = $this->response;
        $auth = end($this->_authenticateObjects);
        if ($auth === false) {
            throw new Exception('At least one authenticate object must be available.');
        }
        $result = $auth->unauthenticated($controller->getRequest(), $response);
        if ($result !== null) {
            return $result;
        }

        if (!$controller->getRequest()->is('ajax')) {
			// Hack from extended. Start. Incorporación de mensaje para timeout error.
            //$this->flash($this->_config['authError']);
            $storage = $this->storage();

            if ($storage instanceof \Custom\Auth\Storage\StorageInterface && $storage->isTimeoutExpired()) {
				$this->flash($this->_config['timeoutError']);
			} else {
				$this->flash($this->_config['authError']);
			}
			// Hack from extended. End. Incorporación de mensaje para timeout error.

            return $controller->redirect($this->_loginActionRedirectUrl());
        }

        if (!empty($this->_config['ajaxLogin'])) {
            $controller->viewBuilder()->setTemplatePath('Element');
            $response = $controller->render(
                $this->_config['ajaxLogin'],
                $this->RequestHandler->ajaxLayout
            );
        }

        return $response->withStatus(403);
    }

    /**
     * Returns the URL of the login action to redirect to.
     *
     * This includes the redirect query string if applicable.
     *
     * @return array|string
     */
    protected function _loginActionRedirectUrl()
    {
        $urlToRedirectBackTo = $this->_getUrlToRedirectBackTo();

        $loginAction = $this->_config['loginAction'];
		
        // Hack from extended. Start. Si la acción a la que se debe redireccionar es de logout se cancela la redirección.
        //if ($urlToRedirectBackTo === '/') {
        if ($urlToRedirectBackTo === '/' || $urlToRedirectBackTo === Router::normalize($this->_config['logoutAction'])) {
            return $loginAction;
        }
        // Hack from extended. End. Si la acción a la que se debe redireccionar es de logout se cancela la redirección.

        if (is_array($loginAction)) {
            $loginAction['?'][static::QUERY_STRING_REDIRECT] = $urlToRedirectBackTo;
        } else {
            $char = strpos($loginAction, '?') === false ? '?' : '&';
            $loginAction .= $char . static::QUERY_STRING_REDIRECT . '=' . urlencode($urlToRedirectBackTo);
        }

        return $loginAction;
    }

    /**
     * Handle unauthorized access attempt
     *
     * @param \Cake\Controller\Controller $controller A reference to the controller object
     * @return \Cake\Http\Response
     * @throws \Cake\Http\Exception\ForbiddenException
     */
    protected function _unauthorized(Controller $controller)
    {
        if ($this->_config['unauthorizedRedirect'] === false) {
            throw new ForbiddenException($this->_config['authError']);
        }

        $this->flash($this->_config['authError']);
        if ($this->_config['unauthorizedRedirect'] === true) {
            $default = '/';
            if (!empty($this->_config['loginRedirect'])) {
                $default = $this->_config['loginRedirect'];
            }
            if (is_array($default)) {
                $default['_base'] = false;
            }
            $url = $controller->referer($default, true);
            
			// Hack from extended. Start. Verifica que la redirección no sea igual a la acción actual bloqueada
            /* Cuando el login es exitoso pero redirige a una página no autorizada, puede producirse un bucle infinito si se controla la presencia de un id de usuario en la forma:
                if ($this->Auth->user('id')) {
                    return $this->redirect($this->Auth->redirectUrl());
                }
            Ya que, al ser una página no autorizada, redirigirá la acción a la referencia; para este caso, el login. Pero al estar el usuario ya logeado, redirigirá nuevamente la acción a la página indicada en el login, que es justamente la página bloqueada. */
            $urlPath = parse_url($url, PHP_URL_PATH);
            $urlQuery = parse_url($url, PHP_URL_QUERY);
            
            parse_str($urlQuery, $urlQueryParsed);
            
            if (isset($urlQueryParsed['redirect']) && Router::normalize($urlQueryParsed['redirect']) == Router::normalize($this->_getUrlToRedirectBackTo()))  {
                $url = $urlPath;
                unset($urlQueryParsed['redirect']);
                if (count($urlQueryParsed) > 0) {
                    $url .= '?'.http_build_query($urlQueryParsed);
                }
            }
 			// Hack from extended. End. Verifica que la redirección no sea igual a la acción actual bloqueada

 			// Hack from extended. Start. Si el permiso de la referencia cambió luego de la acción, se redirige a la página por defecto, que siempre estará disponible (Pasa cuando se emula a un usuario que no tiene permiso a una página que el usuario original si tiene)
            if (Router::normalize($url) == Router::normalize($this->_getUrlToRedirectBackTo())) {
                $url = $default;
            }
 			// Hack from extended. End. Si el permiso de la referencia cambió luego de la acción, se redirige a la página por defecto, que siempre estará disponible (Pasa cuando se emula a un usuario que no tiene permiso a una página que el usuario original si tiene)
        
        } else {
            $url = $this->_config['unauthorizedRedirect'];
        }

        return $controller->redirect($url);
    }

    /**
     * Sets defaults for configs.
     *
     * @return void
     */
    protected function _setDefaults()
    {
        $defaults = [
            'authenticate' => ['Form'],
            'flash' => [
                'element' => 'error',
                'key' => 'flash',
                'params' => ['class' => 'error']
            ],
            'loginAction' => [
                'controller' => 'Users',
                'action' => 'login',
                'plugin' => null
            ],
            'logoutAction' => [
                'controller' => 'Users',
                'action' => 'logout',
                'plugin' => null
            ], // Hack from extended. Default logout action
            'logoutRedirect' => $this->_config['loginAction'],
            'authError' => __d('cake', 'You are not authorized to access that location.'),
            'timeoutError' => __d('custom', 'Your session has expired. Please log in.') // Hack from extended. Add timeoutError message
        ];

        $config = $this->getConfig();
        foreach ($config as $key => $value) {
            if ($value !== null) {
                unset($defaults[$key]);
            }
        }
        $this->setConfig($defaults);
    }

    /**
     * Recupera la información del usuario almacenada en la sesión desde la base de datos.
     *
     * @param $id Identifier.
     * @return bool|array Either false on failure, or an array of user data.
     */
	public function freshUser($id)
	{
		if (empty($this->_authenticateObjects)) {
            $this->constructAuthenticate();
        }
        foreach ($this->_authenticateObjects as $auth) {
            $result = $auth->freshUser($id);
            if (!empty($result)) {
                $this->_authenticationProvider = $auth;
                $event = $this->dispatchEvent('Auth.afterRefreshUser', [$result, $auth]);
                if ($event->getResult() !== null) {
                    return $event->getResult();
                }

                return $result;
            }
        }

        return false;
	}
	
    /**
     * Actualiza la información del usuario almacenada en la sesión con la obtenida de la base de datos.
     *
     * @return void
     */
	public function refreshUser()
	{
 		if ($user = $this->freshUser($this->user('id'))) {
			$this->setUser(Hash::merge($this->user(), $user));
		}
	}

	public function emulateUser($id)
	{
        if ($id != $this->user('id')) {
			if ($id == $this->user('restore.id')) {
				$this->restoreUser();
			} else {
				if ($user = $this->freshUser($id)) {
					if (!$restore = $this->user('restore')) {
						$restore = $this->user();
					}
					$user['restore'] = $restore;

				}
                $this->setUser($user);
            }
		}
	}
	
	public function restoreUser()
	{
		if ($restore = $this->user('restore')) {
			$this->setUser($restore);
		}
	}
}